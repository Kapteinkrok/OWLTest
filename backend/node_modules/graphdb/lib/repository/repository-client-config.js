"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Configuration wrapper used for initialization of {@link BaseRepositoryClient}
 * implementations.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
var RepositoryClientConfig =
/*#__PURE__*/
function () {
  /**
   * @param {string[]} [endpoints] is an array with repository endpoints
   * @param {Object} [headers] is a key:value mapping of http headers and values
   * @param {string} [defaultRDFMimeType] one of {@link RDFMimeType} values
   * @param {number} [readTimeout]
   * @param {number} [writeTimeout]
   * @param {string} [username] username which should be authenticated
   * @param {string} [pass] the password to be used
   * @param {boolean} [keepAlive] if the logged in user should be
   * reauthenticated after auth token expire. This config has meaning when the
   * server is secured and username and passwords are provided.
   */
  function RepositoryClientConfig(endpoints, headers, defaultRDFMimeType, readTimeout, writeTimeout, username, pass, keepAlive) {
    _classCallCheck(this, RepositoryClientConfig);

    this.endpoints = endpoints;
    this.headers = headers;
    this.defaultRDFMimeType = defaultRDFMimeType;
    this.readTimeout = readTimeout;
    this.writeTimeout = writeTimeout;
    this.username = username;
    this.pass = pass;
    this.keepAlive = keepAlive !== undefined ? keepAlive : true;
  }
  /**
   * Sets the repository endpoint URLs.
   *
   * @param {string[]} endpoints the endpoint URLs
   *
   * @return {RepositoryClientConfig} current config for method chaining
   */


  _createClass(RepositoryClientConfig, [{
    key: "setEndpoints",
    value: function setEndpoints(endpoints) {
      this.endpoints = endpoints;
      return this;
    }
    /**
     * Inserts a repository endpoint URL to the rest of the endpoints.
     *
     * @param {string} endpoint repository endpoint URL
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */

  }, {
    key: "addEndpoint",
    value: function addEndpoint(endpoint) {
      if (!this.endpoints) {
        this.endpoints = [];
      }

      this.endpoints.push(endpoint);
      return this;
    }
    /**
     * Gets the repository endpoint URLs.
     *
     * @return {string[]}
     */

  }, {
    key: "getEndpoints",
    value: function getEndpoints() {
      return this.endpoints;
    }
    /**
     * Sets the default headers map for each HTTP request.
     *
     * @param {Object<string, string>} headers the map of default headers
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */

  }, {
    key: "setHeaders",
    value: function setHeaders(headers) {
      this.headers = headers;
      return this;
    }
    /**
     * Returns the default headers map for each HTTP request.
     *
     * @return {Object<string, string>}
     */

  }, {
    key: "getHeaders",
    value: function getHeaders() {
      return this.headers;
    }
    /**
     * Sets the default RDF MIME type.
     *
     * @param {string} defaultRDFMimeType
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */

  }, {
    key: "setDefaultRDFMimeType",
    value: function setDefaultRDFMimeType(defaultRDFMimeType) {
      this.defaultRDFMimeType = defaultRDFMimeType;
      return this;
    }
    /**
     * Returns the default RDF MIME type.
     *
     * @return {string}
     */

  }, {
    key: "getDefaultRDFMimeType",
    value: function getDefaultRDFMimeType() {
      return this.defaultRDFMimeType;
    }
    /**
     * Sets the default read timeout for HTTP requests.
     *
     * @param {number} readTimeout the timeout in milliseconds
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */

  }, {
    key: "setReadTimeout",
    value: function setReadTimeout(readTimeout) {
      this.readTimeout = readTimeout;
      return this;
    }
    /**
     * Returns the default read timeout for HTTP requests.
     *
     * @return {number}
     */

  }, {
    key: "getReadTimeout",
    value: function getReadTimeout() {
      return this.readTimeout;
    }
    /**
     * Sets the default write timeout for HTTP requests.
     *
     * @param {number} writeTimeout the timeout in milliseconds
     *
     * @return {RepositoryClientConfig} current config for method chaining
     */

  }, {
    key: "setWriteTimeout",
    value: function setWriteTimeout(writeTimeout) {
      this.writeTimeout = writeTimeout;
      return this;
    }
    /**
     * Returns the default write timeout for HTTP requests.
     *
     * @return {number}
     */

  }, {
    key: "getWriteTimeout",
    value: function getWriteTimeout() {
      return this.writeTimeout;
    }
    /**
     * @return {string} the username
     */

  }, {
    key: "getUsername",
    value: function getUsername() {
      return this.username;
    }
    /**
     * @param {string} username
     * @return {RepositoryClientConfig} the current config for method chaining
     */

  }, {
    key: "setUsername",
    value: function setUsername(username) {
      this.username = username;
      return this;
    }
    /**
     * @return {string} the user password
     */

  }, {
    key: "getPass",
    value: function getPass() {
      return this.pass;
    }
    /**
     * @param {string} pass
     * @return {RepositoryClientConfig} the current config for method chaining
     */

  }, {
    key: "setPass",
    value: function setPass(pass) {
      this.pass = pass;
      return this;
    }
    /**
     * @return {boolean} if the user should be re-logged in after token expires
     */

  }, {
    key: "getKeepAlive",
    value: function getKeepAlive() {
      return this.keepAlive;
    }
    /**
     * @param {boolean} keepAlive
     * @return {ServerClientConfig} the current config for method chaining
     */

  }, {
    key: "setKeepAlive",
    value: function setKeepAlive(keepAlive) {
      this.keepAlive = keepAlive;
      return this;
    }
  }]);

  return RepositoryClientConfig;
}();

module.exports = RepositoryClientConfig;
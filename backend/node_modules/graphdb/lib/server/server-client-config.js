"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Configuration wrapper used for initialization of {@link ServerClient}
 * instances.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */
var ServerClientConfig =
/*#__PURE__*/
function () {
  /**
   * @param {string} [endpoint] Endpoint url.
   * @param {number} [timeout] Specifies the number of milliseconds before the
   *                         request times out.
   * @param {Map<string, string>} [headers] An http headers map.
   * @param {string} [username] username which should be authenticated
   * @param {string} [pass] the password to be used
   * @param {boolean} [keepAlive=true] if the logged in user should be
   * reauthenticated after auth token expire. This config has meaning when the
   * server is secured and username and passwords are provided.
   */
  function ServerClientConfig(endpoint, timeout, headers, username, pass, keepAlive) {
    _classCallCheck(this, ServerClientConfig);

    this.endpoint = endpoint;
    this.timeout = timeout;
    this.headers = headers;
    this.username = username;
    this.pass = pass;
    this.keepAlive = keepAlive !== undefined ? keepAlive : true;
  }
  /**
   * Sets the server's endpoint URL.
   *
   * @param {string} endpoint the endpoint URL
   *
   * @return {ServerClientConfig} the current config for method chaining
   */


  _createClass(ServerClientConfig, [{
    key: "setEndpoint",
    value: function setEndpoint(endpoint) {
      this.endpoint = endpoint;
      return this;
    }
    /**
     * Returns the server's endpoint URL.
     *
     * @return {string} the endpoint URL
     */

  }, {
    key: "getEndpoint",
    value: function getEndpoint() {
      return this.endpoint;
    }
    /**
     * Sets the default headers map for each HTTP request.
     *
     * @param {Object<string, string>} headers the default headers
     *
     * @return {ServerClientConfig} the current config for method chaining
     */

  }, {
    key: "setHeaders",
    value: function setHeaders(headers) {
      this.headers = headers;
      return this;
    }
    /**
     * Returns the default headers for each HTTP request.
     *
     * @return {Object<string, string>} the default headers map
     */

  }, {
    key: "getHeaders",
    value: function getHeaders() {
      return this.headers;
    }
    /**
     * Sets the timeout for HTTP requests.
     *
     * @param {number} timeout the timeout in milliseconds
     *
     * @return {ServerClientConfig} the current config for method chaining
     */

  }, {
    key: "setTimeout",
    value: function setTimeout(timeout) {
      this.timeout = timeout;
      return this;
    }
    /**
     * Returns the HTTP requests's timeout.
     *
     * @return {number} the timeout in milliseconds
     */

  }, {
    key: "getTimeout",
    value: function getTimeout() {
      return this.timeout;
    }
    /**
     * @return {string} the username
     */

  }, {
    key: "getUsername",
    value: function getUsername() {
      return this.username;
    }
    /**
     * @param {string} username
     * @return {ServerClientConfig} the current config for method chaining
     */

  }, {
    key: "setUsername",
    value: function setUsername(username) {
      this.username = username;
      return this;
    }
    /**
     * @return {string} the user password
     */

  }, {
    key: "getPass",
    value: function getPass() {
      return this.pass;
    }
    /**
     * @param {string} pass
     * @return {ServerClientConfig} the current config for method chaining
     */

  }, {
    key: "setPass",
    value: function setPass(pass) {
      this.pass = pass;
      return this;
    }
    /**
     * @return {boolean} if the user should be re-logged in after token expires
     */

  }, {
    key: "getKeepAlive",
    value: function getKeepAlive() {
      return this.keepAlive;
    }
    /**
     * @param {boolean} keepAlive
     * @return {ServerClientConfig} the current config for method chaining
     */

  }, {
    key: "setKeepAlive",
    value: function setKeepAlive(keepAlive) {
      this.keepAlive = keepAlive;
      return this;
    }
  }]);

  return ServerClientConfig;
}();

module.exports = ServerClientConfig;